// SPDX-License-Identifier: MIT
pragma solidity >=0.8.13;

import { D03ProtocolDefaults, console2, LibAdmin, LibConstants, LibHelpers } from "./defaults/D03ProtocolDefaults.sol";
import { MockAccounts } from "./utils/users/MockAccounts.sol";
import { ERC20 } from "src/erc20/ERC20.sol";
import "forge-std/Vm.sol";
import { INonfungiblePositionManager } from "./contracts/uniswap-interfaces/INonfungiblePositionManager.sol";
import { IUniswapV3Factory } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol";
import { IUniswapV3Pool } from "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol";
import { INonfungibleTokenPositionDescriptor } from "./contracts/uniswap-interfaces/INonfungibleTokenPositionDescriptor.sol";
import { TransferHelper } from "@uniswap/v3-periphery/contracts/libraries/TransferHelper.sol";
import { TickMath } from "src/diamonds/nayms/libs/TickMath.sol";
import "src/diamonds/nayms/libs/Tick.sol";
import { Entity } from "src/diamonds/nayms/AppStorage.sol";

import { AppStorage, LibAppStorage } from "src/diamonds/nayms/AppStorage.sol";
import { initEntity } from "./T04Entity.t.sol";
import { LibNDF } from "src/diamonds/nayms/libs/LibNDF.sol";
import { LibTokenizedVault } from "src/diamonds/nayms/libs/LibTokenizedVault.sol";

contract MockERC20 is ERC20 {
    constructor(
        string memory _name,
        string memory _symbol,
        uint8 _decimals
    ) ERC20(_name, _symbol, _decimals) {}

    function mint(address to, uint256 value) public virtual {
        _mint(to, value);
    }

    function burn(address from, uint256 value) public virtual {
        _burn(from, value);
    }
}

contract T04NDFTest is D03ProtocolDefaults, MockAccounts {
    bytes32 internal objectContext1 = "0xe1b";
    bytes32 internal objectContext2 = "0xe1c";
    bytes32 internal objectContext3 = "0xe1d";
    bytes32 internal objectContext4 = "0xe1e";

    IUniswapV3Factory public factory;
    INonfungiblePositionManager public nft;
    INonfungibleTokenPositionDescriptor public nftDescriptor;

    MockERC20 public token0;
    MockERC20 public token1;

    function setUp() public virtual override {
        super.setUp();

        Entity memory entity1 = initEntity(weth, 500, 1000, 1000, false);
        Entity memory entity2 = initEntity(weth, 500, 1000, 1000, false);
        Entity memory entity3 = initEntity(weth, 500, 1000, 1000, false);
        Entity memory entity4 = initEntity(weth, 500, 1000, 1000, false);

        nayms.createEntity(LibHelpers._stringToBytes32(LibConstants.NDF_IDENTIFIER), objectContext1, entity1);

        nayms.createEntity(LibHelpers._stringToBytes32(LibConstants.SSF_IDENTIFIER), objectContext2, entity2);

        nayms.createEntity(LibHelpers._stringToBytes32(LibConstants.STM_IDENTIFIER), objectContext3, entity3);

        nayms.createEntity(LibHelpers._stringToBytes32(LibHelpers._bytes32ToString(LibHelpers._getIdForAddress(account1))), objectContext4, entity4);

        address _factory = 0x1F98431c8aD98523631AE4a59f267346ea31F984;
        factory = IUniswapV3Factory(_factory);
        nftDescriptor = INonfungibleTokenPositionDescriptor(0x91ae842A5Ffd8d12023116943e72A606179294f3);

        nft = INonfungiblePositionManager(0xC36442b4a4522E871399CD717aBDD847Ab11FE88);
    }

    /// @notice Mints external tokens and deploys Liquidity Pools
    /// @dev Mints and approves external tokens, does externalDeposit to put them in the internal system and calls createPool().
    function deployTokensAndCreateLP() public {
        token0 = new MockERC20("Test1", "TEST1", 18);

        token0.mint(address(account0), 100000 ether);

        token0.mint(LibHelpers._getAddressFromId(LibHelpers._stringToBytes32(LibConstants.NDF_IDENTIFIER)), 10000);

        token0.mint(address(nayms), 10000);

        token0.approve(address(nft), 10000 ether);

        token0.approve(LibHelpers._getAddressFromId(LibHelpers._stringToBytes32(LibConstants.NDF_IDENTIFIER)), 10000);

        token0.approve(address(nayms), 10000);

        token0.approve(address(account0), 100000);

        nayms.approve(address(nft), 10000 ether);

        nayms.approve(address(nayms), 100e18);

        nayms.approve(LibHelpers._getAddressFromId(LibHelpers._stringToBytes32(LibConstants.NDF_IDENTIFIER)), 10000);

        nayms.addSupportedExternalToken(address(token0));

        nayms.externalDeposit(LibHelpers._stringToBytes32(LibConstants.NDF_IDENTIFIER), address(nayms), 100);

        nayms.externalDeposit(LibHelpers._stringToBytes32(LibConstants.NDF_IDENTIFIER), address(token0), 100);

        nayms.externalDeposit(DEFAULT_ACCOUNT0_ENTITY_ID, address(token0), 100);

        uint256 amount = 10000;
        address ndf = LibHelpers._getAddressFromId(LibHelpers._stringToBytes32(LibConstants.NDF_IDENTIFIER));
        weth.approve(address(nayms), amount);
        weth.approve(address(account0), amount);
        weth.approve(ndf, amount);
        weth.approve(address(this), amount);
        address assetAddress = address(weth);
        writeTokenBalance(account0, address(nayms), assetAddress, amount);
        writeTokenBalance(account0, address(nayms), address(token0), amount);
        writeTokenBalance(LibHelpers._getAddressFromId(LibHelpers._stringToBytes32(LibConstants.NDF_IDENTIFIER)), address(nayms), assetAddress, amount);

        nayms.addSupportedExternalToken(address(weth));

        nayms.externalDeposit(DEFAULT_ACCOUNT0_ENTITY_ID, assetAddress, 100);
        nayms.externalDeposit(DEFAULT_ACCOUNT0_ENTITY_ID, address(token0), 100);
        nayms.externalDeposit(LibHelpers._stringToBytes32(LibConstants.NDF_IDENTIFIER), assetAddress, 100);

        createPool(address(token0), address(nayms), 100, 100);
        createPool(address(nayms), address(weth), 100, 100);
        createPool(address(token0), address(weth), 100, 100);
    }

    /// @notice Creates 3 Uniswap V3 LPs of Nayms, token0 & test wETH.
    function createPool(
        address token0,
        address token1,
        uint256 amount0,
        uint256 amount1
    ) public {
        if (token0 > token1) {
            address tmp = token0;
            token0 = token1;
            token1 = tmp;
        }

        address pool = nft.createAndInitializePoolIfNecessary(token0, token1, FEE_MEDIUM, encodePriceSqrt(1, 1));

        weth.approve(pool, amount1);
        INonfungiblePositionManager.MintParams memory params = INonfungiblePositionManager.MintParams({
            token0: token0,
            token1: token1,
            fee: FEE_MEDIUM,
            tickLower: getMinTick(TICK_MEDIUM),
            tickUpper: getMaxTick(TICK_MEDIUM),
            amount0Desired: amount0,
            amount1Desired: amount1,
            amount0Min: 0,
            amount1Min: 0,
            recipient: address(account0),
            deadline: block.timestamp + 10
        });

        TransferHelper.safeApprove(token0, pool, 100000);
        TransferHelper.safeApprove(token1, pool, 100000);

        TransferHelper.safeApprove(token0, address(nft), 100000);
        TransferHelper.safeApprove(token1, address(nft), 100000);

        nft.mint(params);
    }

    /// @notice tests that users without authorization cannot pay the SSF
    function testFailPaySubSurplusFund() public {
        vm.startPrank(account1);
        nayms.paySubSurplusFund(1000);
        vm.expectRevert("not a system admin");
        vm.stopPrank();
    }

    /// @notice Tests that paying the SSF updates balances accordingly.
    function testPaySubSurplusFund() public {
        vm.startPrank(account0);

        nayms.approve(address(nayms), 100e18);
        nayms.externalDeposit(LibHelpers._stringToBytes32(LibConstants.NDF_IDENTIFIER), address(nayms), 1000);

        assertEq(nayms.internalBalanceOf(LibHelpers._stringToBytes32(LibConstants.NDF_IDENTIFIER), naymsTokenId), 1000);

        uint256 ssfStartBalance = nayms.internalBalanceOf(LibHelpers._stringToBytes32(LibConstants.SSF_IDENTIFIER), naymsTokenId);

        nayms.paySubSurplusFund(100);

        assertEq(nayms.internalBalanceOf(LibHelpers._stringToBytes32(LibConstants.NDF_IDENTIFIER), naymsTokenId), 900);

        assertEq(nayms.internalBalanceOf(LibHelpers._stringToBytes32(LibConstants.SSF_IDENTIFIER), naymsTokenId), ssfStartBalance + 100);

        vm.stopPrank();
    }

    /// @notice Fuzz test for paying the SSF.
    function testFuzzPaySubSurplusFund(bytes32 _naymsVaultToken, uint256 _amount) public {
        vm.startPrank(account0);
        nayms.approve(address(nayms), 100e18);
        nayms.externalDeposit(LibHelpers._stringToBytes32(LibConstants.NDF_IDENTIFIER), address(nayms), 10e18);
        _amount = bound(_amount, 1, 10000);
        nayms.paySubSurplusFund(_amount);
    }

    /// @notice tests that users with amount 0 cannot buy Nayms.
    function testFailBuyNayms() public {
        vm.startPrank(account1);
        nayms.buyNayms(0);
        vm.expectRevert("amount must be > 0");
        vm.stopPrank();
    }

    /// @notice Buy discounted Nayms as entity of account 0, checks that staking mechanism balance gets updated after purchase.
    function testBuyNayms() public {
        vm.startPrank(account0);

        nayms.setDiscountToken(0x199f329120f55D17382cc2EDBFa73aeAe06d6A8E);

        deployTokensAndCreateLP();

        changePrank(LibHelpers._getAddressFromId(DEFAULT_ACCOUNT0_ENTITY_ID));

        uint256 stakingStartBalance = nayms.internalBalanceOf(LibHelpers._stringToBytes32(LibConstants.STM_IDENTIFIER), naymsTokenId);
        weth.approve(account0, 1000);

        assertEq(stakingStartBalance, 0);

        nayms.buyNayms(10);

        assert(nayms.internalBalanceOf(LibHelpers._stringToBytes32(LibConstants.STM_IDENTIFIER), naymsTokenId) > stakingStartBalance);

        vm.stopPrank();
    }

    /// @notice NaymsValueRatio = s.actualNaymsAllocation
    /// @dev LP has 33% Nayms value relative to total asset value so should equal 33.
    function testGetNaymsValueRatio() public {
        vm.startPrank(account0);

        deployTokensAndCreateLP();

        assertEq(nayms.getNaymsValueRatio(), 33);

        vm.stopPrank();
    }

    /// @notice Tests that discount for buying Nayms is calculated correctly.
    function testGetDiscount() public {
        // naymsAlloc = 330 (33% of NDF Value Balance)
        // _maxWilling = 20
        // np = 10
        // maxDiscount = 10
        // target = 200
        // numerator = 243890000
        // denominator = 512000000000
        // discount = 0.68
        deployTokensAndCreateLP();

        assertEq(nayms.getDiscount(20), 0);
    }
}
