// SPDX-License-Identifier: MIT
pragma solidity >=0.8.13;

import { D03ProtocolDefaults, console2, LibAdmin, LibConstants, LibHelpers } from "./defaults/D03ProtocolDefaults.sol";

contract T04StakingTest is D03ProtocolDefaults {

    // IncreaseAmount only executes depositFor no need to write tests for that one.
    // IncreaseAmount calls depositFor for msg.sender.

    bytes32 public immutable stmId = LibHelpers._stringToBytes32(LibConstants.STM_IDENTIFIER);

    function setUp() public virtual override {
        super.setUp();
    }

    function testExchangeRateWhenThereAreNoStakedTokens() public {
        assertEq(nayms.exchangeRate(), 1e18);
    }

    function testStaking() public {
        nayms.approve(address(nayms), 100e18);
        // nayms.externalDeposit(account0Id, address(nayms), 10e18);

        // // check balance of user's nNAYM
        // assertEq(nayms.internalBalanceOf(account0Id, naymsTokenId), 10e18);
        // // check total supply of nNAYM
        // assertEq(nayms.internalTokenSupply(naymsTokenId), 10e18);

        uint256 defaultMintAmount = 1_000_000_000e18;
        assertEq(nayms.balanceOf(account0), defaultMintAmount);
        uint256 lockDuration = 100 days;
        uint256 stakeDepositAmount = 1e18;
        nayms.createLock(account0, stakeDepositAmount, lockDuration);
        assertEq(nayms.balanceOf(account0), defaultMintAmount - stakeDepositAmount);

        // check balance of user's nNAYM
        // assertEq(nayms.internalBalanceOf(account0Id, naymsTokenId), 10e18 - 1e18);
        assertBalance(stakeDepositAmount);

        nayms.getUserLockedBalanceEndTime(account0);

        uint256 beforeDepositVENAYMForNAYM = nayms.getVENAYMForNAYM(1e18);
        nayms.depositFor(account0, 1e18);

        nayms.internalTokenSupply(naymsTokenId);
        nayms.internalTokenSupply(stmId);
        // check balances after deposit
        assertEq(nayms.internalBalanceOf(account0Id, naymsTokenId), 0);
        assertEq(nayms.internalBalanceOf(account0Id, stmId), 1e18 + beforeDepositVENAYMForNAYM);

        vm.warp(block.timestamp + 1 days);
    }

    function testUserCannotTransferStakedTokens() public {
        testStaking();

        bytes32 randomEntityId = "Random Entity ID";

        vm.expectRevert("internalTransfer: can't transfer internal veNAYM");
        nayms.internalTransfer(randomEntityId, stmId, 1e18);

        vm.expectRevert("internalTransfer: can't transfer internal veNAYM");
        nayms.internalTransfer(account0Id, stmId, 1e18);
    }

    function testWithdrawStakedTokens() public {
        testStaking();

        vm.expectRevert("STAKING: UNLOCK TIME NOT REACHED");
        nayms.withdraw();

        nayms.getUserLockedBalanceEndTime(account0);

        vm.warp(block.timestamp + 100 days);
        nayms.withdraw();
    }

    function testIncreaseUnlockTimeBy10Days() public {
        testStaking();
        uint256 originalLockTime = nayms.getUserLockedBalanceEndTime(account0);
        uint256 increaseLockDuration = 10 days;
        nayms.increaseUnlockTime(increaseLockDuration);
        uint256 newLockTime = nayms.getUserLockedBalanceEndTime(account0);
        assertEq(originalLockTime < newLockTime, true);
    }

    function testIncreaseUnlockTimeRevertAssetsNonExisting() public{
        uint256 increaseLockDuration = 10 days;
        vm.expectRevert("STAKING: NO EXISTING LOCK");
        nayms.increaseUnlockTime(increaseLockDuration);
    }

    function testIncreaseUnlockTimeLockExpired() public {
        testStaking();
        uint256 originalLockTime = nayms.getUserLockedBalanceEndTime(account0);
        vm.warp(block.timestamp + 100 days);

        uint256 increaseLockDuration = 10 days;
        vm.expectRevert("STAKING: LOCK EXPIRED");
        nayms.increaseUnlockTime(increaseLockDuration);
    }

    function testIncreaseUnlockTimeOverMaxLockTime() public {
        testStaking();
        uint256 originalLockTime = nayms.getUserLockedBalanceEndTime(account0);
        uint256 increaseLockDuration = 10000 days;
        vm.expectRevert("STAKING: OVER MAX LOCK TIME");
        nayms.increaseUnlockTime(increaseLockDuration);
    }

    function testCreateLockRevertStakingZeroAmount() public {
        nayms.approve(address(nayms), 100e18);

        uint256 lockDuration = 100 days;
        uint256 stakeDepositAmount = 0e18;
        vm.expectRevert("STAKING: ZERO VALUE");
        nayms.createLock(account0, stakeDepositAmount, lockDuration);
    }

    function testCreateLockRevertStakingOverMaxTimeByDay() public {
        nayms.approve(address(nayms), 100e18);
        uint256 defaultMintAmount = 1_000_000_000e18;
        assertEq(nayms.balanceOf(account0), defaultMintAmount);
        uint256 lockDuration = 5 * 366 days;
        uint256 stakeDepositAmount = 1e18;
        vm.expectRevert("STAKING: MORE THAN MAX TIME");
        nayms.createLock(account0, stakeDepositAmount, lockDuration);
    }

    function testCreateLockExistingAmountNotWithdrawn() public {
        nayms.approve(address(nayms), 100e18);
        uint256 defaultMintAmount = 1_000_000_000e18;
        assertEq(nayms.balanceOf(account0), defaultMintAmount);
        uint256 lockDuration = 100 days;
        uint256 stakeDepositAmount = 1e18;
        nayms.createLock(account0, stakeDepositAmount, lockDuration);
        vm.warp(block.timestamp + 101 days);
        vm.expectRevert("STAKING: WITHDRAW EXISTING FIRST");
        nayms.createLock(account0, stakeDepositAmount, lockDuration);
    }

    function testCreateLockAfterWithdrawal() public {
        nayms.approve(address(nayms), 100e18);
        uint256 defaultMintAmount = 1_000_000_000e18;
        assertEq(nayms.balanceOf(account0), defaultMintAmount);
        uint256 lockDuration = 100 days;
        uint256 stakeDepositAmount = 1e18;
        nayms.createLock(account0, stakeDepositAmount, lockDuration);

        vm.warp(block.timestamp + 101 days);
        nayms.withdraw();

        nayms.createLock(account0, stakeDepositAmount, lockDuration);
    }


    function testCreateLockDefaultAmount() public {
        nayms.approve(address(nayms), 100e18);
        uint256 defaultMintAmount = 1_000_000_000e18;
        assertEq(nayms.balanceOf(account0), defaultMintAmount);
        uint256 lockDuration = 100 days;
        uint256 stakeDepositAmount = 1e18;
        nayms.createLock(account0, stakeDepositAmount, lockDuration);
        assertBalance(stakeDepositAmount);

    }

    function testDepositFor() public {
        nayms.approve(address(nayms), 100e18);
        uint256 defaultMintAmount = 1_000_000_000e18;
        assertEq(nayms.balanceOf(account0), defaultMintAmount);
        uint256 lockDuration = 100 days;
        uint256 stakeDepositAmount = 1e18;
        nayms.createLock(account0, stakeDepositAmount, lockDuration);
        nayms.depositFor(account0, stakeDepositAmount);
        
        assertBalance(stakeDepositAmount*2);
    }

    function testDepositForZeroValue() public {
        nayms.approve(address(nayms), 100e18);
        uint256 defaultMintAmount = 1_000_000_000e18;
        assertEq(nayms.balanceOf(account0), defaultMintAmount);
        uint256 lockDuration = 100 days;
        uint256 stakeDepositAmount = 1e18;
        nayms.createLock(account0, stakeDepositAmount, lockDuration);
        assertBalance(stakeDepositAmount);

        uint256 increaseDepositAmount = 0e18;
        vm.expectRevert("STAKING: ZERO VALUE");
        nayms.depositFor(account0, increaseDepositAmount);
    }

    function testDepositFortLockDoesntExist() public {
        nayms.approve(address(nayms), 100e18);
        uint256 defaultMintAmount = 1_000_000_000e18;
        uint256 increaseDepositAmount = 1e18;
        vm.expectRevert("STAKING: LOCK DOES NOT EXIST");
        nayms.depositFor(account0, increaseDepositAmount);
    }

    function testDepositForLockExpired() public {
        nayms.approve(address(nayms), 100e18);
        uint256 defaultMintAmount = 1_000_000_000e18;
        assertEq(nayms.balanceOf(account0), defaultMintAmount);
        uint256 lockDuration = 100 days;
        uint256 stakeDepositAmount = 1e18;
        nayms.createLock(account0, stakeDepositAmount, lockDuration);
       
        assertBalance(stakeDepositAmount);
        vm.warp(block.timestamp + 100 days);

        uint256 increaseDepositAmount = 1e18;
        vm.expectRevert("STAKING: LOCKED EXPIRED");
        nayms.depositFor(account0, increaseDepositAmount);
    }


// Internal functions for asserts

    function assertBalance(uint256 amount) public {
        assertEq(nayms.internalBalanceOf(stmId, naymsTokenId), amount);
        assertEq(nayms.internalBalanceOf(account0Id, stmId), amount);
        assertEq(nayms.internalTokenSupply(naymsTokenId), amount);
        assertEq(nayms.internalTokenSupply(stmId), amount);
    }
}

