#!/usr/bin/env node
const path = require('path')
const fs = require('fs')
const glob = require('glob')
const chalk = require('chalk')

const PROJECT_DIR = path.join(__dirname, '..')
const ARTIFACTS_FOLDER = path.join(PROJECT_DIR, 'forge-artifacts')
const FACETS_SRC_DIR = path.join(PROJECT_DIR, 'src', 'diamonds', 'nayms', 'facets')
const FACETS_DEPLOYED_TXT = path.join(PROJECT_DIR, 'facetsdeployed.txt')
const GENERATED_DEPLOY_NAMES_SOL = path.join(PROJECT_DIR, 'script', 'utils', 'LibGeneratedNaymsFacetHelpers.sol')

// load facets
const facetNames = glob.sync('*Facet.sol', { cwd: FACETS_SRC_DIR }).map(a => path.basename(a).substring(0, a.indexOf('Facet')))

// load interfaces and methods
const facetData = {}
facetNames.forEach(f => {
  try {
    const interfaceName = `I${f}Facet`
    const { abi } = JSON.parse(fs.readFileSync(path.join(ARTIFACTS_FOLDER, `${interfaceName}.sol`, `${interfaceName}.json`)))
    const methods = abi.filter(n => n.type === 'function').map(n => n.name)
    facetData[f] = {
      interfaceName,
      methods,
    }
  } catch (err) {
    console.error(chalk.red(`Error loading interface for facet ${f}`))
    throw err
  }
})

console.log(chalk.blue('== Facets =='))
Object.entries(facetData).forEach(([facetName, data]) => {
  console.log(`${facetName} - ${data.methods.length} methods`)
})
fs.writeFileSync(FACETS_DEPLOYED_TXT, facetNames.join("\n"), { encoding: 'utf-8'})

// write metadata solidity file
fs.writeFileSync(GENERATED_DEPLOY_NAMES_SOL, `
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.13 <0.9;

/// ------------------------------------------------------------------------------------------------------------
///
/// NOTE: this file is auto-generated by ${path.basename(__filename)}, please DO NOT modify it directly.
///
/// ------------------------------------------------------------------------------------------------------------

import "src/diamonds/nayms/INayms.sol";
import { Nayms } from "src/diamonds/nayms/Nayms.sol";
import { InitDiamond } from "src/diamonds/nayms/InitDiamond.sol";

${facetNames.map((n, i) => `import { ${n}Facet } from "src/diamonds/nayms/facets/${n}Facet.sol";`).join("\n")}

enum NaymsFacetAddressIndex {
  ${facetNames.join(",\n  ")}
}

library LibGeneratedNaymsFacetHelpers {
  function getFacetNames() internal pure returns (string[] memory facetNames) {
    facetNames = new string[](${facetNames.length});
    ${facetNames.map((n, i) => `facetNames[${i}] = "${n}";`).join("\n    ")}
  }

  function createNaymsDiamondFunctionsCut(address[] memory facetAddresses) internal pure returns (IDiamondCut.FacetCut[] memory cut) {
    // initialize the diamond as well as cut in all facets
    cut = new IDiamondCut.FacetCut[](${facetNames.length});

    // yul too slow, so fix stack too deep here
    {
      ${facetNames.map((n, i) => {
        const { interfaceName, methods } = facetData[n];
        
        const selectors = methods.map((m, mi) => `f${i}[${mi}] = ${interfaceName}.${m}.selector;`)

        const str1 = `bytes4[] memory f${i} = new bytes4[](${methods.length});
      ${selectors.join("\n      ")}`

        const str2 = `cut[${i}] = IDiamondCut.FacetCut({
          facetAddress: address(facetAddresses[uint256(NaymsFacetAddressIndex.${n})]),
          action: IDiamondCut.FacetCutAction.Add,
          functionSelectors: f${i}
      });`
        
        return `${str1}\n      ${str2}`
      }).join("\n      ")}
    }
  }

  function deployNaymsFacets() internal returns (address[] memory facetAddresses) {
    facetAddresses = new address[](${facetNames.length});
    ${facetNames.map(n => `facetAddresses[uint256(NaymsFacetAddressIndex.${n})] = address(new ${n}Facet());`).join("\n    ")}
  }

  function deployNaymsFacets(NaymsFacetAddressIndex index) internal returns (address facetAddress) {
    ${facetNames.map(n => `if (index == NaymsFacetAddressIndex.${n}) { return address(new ${n}Facet()); }`).join("\n    ")}
  }

  function deployNaymsFacetsByName(string memory name) internal returns (address facetAddress) {
    if (keccak256(abi.encodePacked(name)) == keccak256(abi.encodePacked("Nayms"))) { return address(new Nayms(msg.sender)); }
    if (keccak256(abi.encodePacked(name)) == keccak256(abi.encodePacked("InitDiamond"))) { return address(new InitDiamond()); }
    ${facetNames.map(n => `if (keccak256(abi.encodePacked(name)) == keccak256(abi.encodePacked("${n}"))) { return address(new ${n}Facet()); }`).join("\n    ")}
  }
}
`, { encoding: 'utf-8'})

